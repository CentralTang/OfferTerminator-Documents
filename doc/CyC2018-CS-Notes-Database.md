# 技术面试必备基础知识-数据库

> 在线阅读：[CS-Notes](https://cyc2018.github.io/CS-Notes/#/README)

## 数据库系统原理 
### 事务
- 概念：事务指的是满足 `ACID` 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。
- ACID：
	- 原子性 (Atomicity)：
		- 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
		- 回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
	- 一致性 (Consistency)：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
	- 隔离性 (Isolation)：一个事务所做的修改在最终提交以前，对其它事务是不可见的。
	- 持久性 (Durability)：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
	
		> 使用重做日志来保证持久性。

- 事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：
	- 只有满足一致性，事务的执行结果才是正确的。
		- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
		- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
	- 事务满足持久化是为了能应对数据库崩溃的情况。  

		| ![图1-1ACID逻辑关系](img/CyC2018-CS-Notes-Database_1-1.png) |
		| :---: |
		| 图 1-1 ACID逻辑关系 |

- AUTOCOMMIT：MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION 语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。

### 并发一致性问题
#### 丢失数据
`丢失数据`：$T_1$ 和 $T_2$ 两个事务都对一个数据进行修改，$T_1$ 先修改，$T_2$ 随后修改，$T_2$ 的修改覆盖了 $T_1$ 的修改。如图 1-2 所示。 

> 简记为 `同时修改`。

#### 读脏数据
`读脏数据`：$T_1$ 对一个数据做了修改，$T_2$ 读取这一个数据。若 $T_1$ 执行 ROLLBACK 操作，则 $T_2$ 读取的结果和第一次的结果不一样。如图 1-3 所示。

> 简记为 `同时读`。

#### 不可重复读
`不可重复读`：$T_2$ 读取一个数据，$T_1$ 对该数据做了修改。如果 $T_2$ 再次读取这个数据，此时读取的结果和第一次读取的结果不同。如图 1-4 所示。

> 简记为 `修改时读`。

#### 幻影读
`幻影读`：$T_1$ 读取某个范围的数据，$T_2$ 在这个范围内插入新的数据，$T_1$ 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。如图 1-5 所示。

> 简记为 `读时修改`。

| ![图1-2丢失数据](img/CyC2018-CS-Notes-Database_1-2.png) | ![图1-3读脏数据](img/CyC2018-CS-Notes-Database_1-3.png) |
| :---: | :---: |
| 图 1-2 丢失数据 | 图 1-3 读脏数据 |
| ![图1-4不可重复读](img/CyC2018-CS-Notes-Database_1-4.png) | ![ 图1-5幻影读](img/CyC2018-CS-Notes-Database_1-5.png) |
| 图 1-4 不可重复读 | 图 1-5 幻影读 |

#### 解决方案
- 在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。
- 产生并发不一致性问题的主要原因是破坏了事务的隔离性。
- 解决方法是通过 `并发控制` 来保证隔离性。
	- 并发控制可以通过 `封锁` 来实现，但是封锁操作需要用户自己控制，相当复杂。
	- 数据库管理系统提供了事务的 `隔离级别`，让用户以一种更轻松的方式处理并发一致性问题。

### 封锁
#### 封锁粒度
- MySQL 中提供了两种封锁粒度：`行级锁` 以及 `表级锁`。
- 应尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。
- 但是加锁需要消耗资源，锁的各种操作 (包括获取锁、释放锁、以及检查锁状态) 都会增加系统开销。因此封锁粒度越小，系统开销就越大。

	> 为此，我们在选择封锁粒度时，需在 `锁开销` 和 `并发程度` 之间做一个 `权衡`。

#### 封锁类型
##### 读写锁
- 排它锁 (Exclusive)，简写为 `X 锁`，又称 `写锁`。
- 共享锁 (Shared)，简写为 `S 锁`，又称 `读锁`。

- 有以下两个规定：
	- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
	- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。
- 锁的兼容关系如表 1-1 所示 :  读写锁之间的兼容关系 

	|  | 排它锁 X | 共享锁 S |
	| :---: | :---: | :---: |
	| 排它锁 X | ✖️ | ✖️ |
	| 共享锁 S | ✖️ | ✔️ |
	
	图例说明：✖️ 相互不兼容	✔️ 相互兼容

##### 意向锁
- 使用意向锁 (Intention Locks)，可以更容易地支持多粒度封锁，使得行锁和表锁能够共存。
- 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

	意向锁在原来的 X/S 锁之上引入了 IX / IS，IX / IS 都是 `表级别的锁`，用来表示一个事务稍后会对表中的某个数据行上加 X 锁或 S 锁。整理可得以下两个规定：
	
	- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
	- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

- 各种锁的兼容关系如表 1-2 所示：读写锁与意向锁的兼容关系
	- 任意 IS / IX 锁之间都是兼容的，因为它们只是表示想要 `对表加锁`，而不是真正加锁；
	- S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。

	|      | 排它锁  X | 意向排它锁 IX | 共享锁 S | 意向共享锁  IS |
	| :---: | :---: | :---: | :---: | :---: |
	| 排它锁 X | ✖️ | ✖️ | ✖️ | ✖️ |
	| 意向排它锁 IX | ✖️ | ✔️ | ✖️ | ✔️ |
	| 共享锁  S | ✖️ | ✖️ | ✔️ | ✔️ |
	| 意向共享锁  IS | ✖️ | ✔️ | ✔️ | ✔️ |
	
	图例说明：✖️ 相互不兼容	✔️ 相互兼容
	
#### 封锁协议
##### 三级封锁协议
- `一级封锁协议`：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。`防止同时修改`

	> 可解决 `丢失修改` 问题，因不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

- `二级封锁协议`：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。`防止修改时读取`

	> 可解决 `丢失修改` 和 `读脏数据` 问题，因为一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。
	
- `三级封锁协议`：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。`防止读取时修改`

	> 可解决 `丢失修改` 和 `读脏数据` 问题，还进一步防止了 `不可重复读` 的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。
	
	|![图1-6一级封锁协议示例](img/CyC2018-CS-Notes-Database_1-6.png) |![图1-7二级封锁协议示例](img/CyC2018-CS-Notes-Database_1-7.png) |![图1-8三级封锁协议示例](img/CyC2018-CS-Notes-Database_1-8.png) |
	| :---: | :---: | :---: |
	| 图 1-6 一级封锁协议示例 | 图 1-7 二级封锁协议示例 | 图 1-8 三级封锁协议示例 |

##### 两段锁协议
- 两段锁协议是指每个事务的执行可以分为两个阶段：生长阶段 (加锁阶段) 和衰退阶段 (解锁阶段)。
- 两段封锁法可以这样来实现：
	- 事务开始后就处于加锁阶段，一直到执行 ROLLBACK 和 COMMIT 之前都是加锁阶段。
	- ROLLBACK 和 COMMIT 使事务进入解锁阶段，即在 ROLLBACK 和 COMMIT 模块中 DBMS 释放所有封锁。
- 可串行化调度：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。
	- 事务遵循两段锁协议是保证可串行化调度的 `充分条件`。例如以下操作满足两段锁协议，它是可串行化调度。

		```html
		lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
		```

	- 但不是 `必要条件`，例如以下操作不满足两段锁协议，但是它还是可串行化调度。

		```html
		lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
		```

#### 隐式与显式锁定
- MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据 `隔离级别` 在需要的时候 `自动加锁`，并且所有的锁都是在同一时刻 (commit 或者 rollback) 被释放，这被称为 `隐式锁定`。
- InnoDB 也可以使用特定的语句进行 `显式锁定` (where 条件里面的必须是主键，否则会锁整张表)：

	```sql
	SELECT ... LOCK In SHARE MODE;
	SELECT ... FOR UPDATE;
	```

### 隔离级别
- 概念：事务指定一个隔离级别，该隔离级别定义一个事务必须与由其他事务进行的资源或数据更改相隔离的程度。隔离级别是从允许并发副作用发生的角度进行描述的。例如，脏读、不可重复读或幻影读。如表 1-3 所示，是关于隔离级别与并发副作用的层级关系。

	| 隔离级别 | 脏读 | 不可重复读 | 幻影读 |
	| :----: | :----: | :----: | :----: |
	| 未提交读 |  ✔️  |  ✔️  |  ✔️  |
	| 提交读   |  ✖️  |  ✔️  |  ✔️  |
	| 可重复读 |  ✖️  |  ✖️  |  ✔️  |
	| 可串行化 |  ✖️  |  ✖️  |  ✖️  |
	
	图例说明：✖️ 是可避免的情况	✔️ 是允许发生的情况
  
- 实现方式：MySQL 的 InnoDB 存储引擎实现隔离级别的具体方式有：多版本并发控制 (MVCC) 与 Next-Key Locks。

#### 未提交读
- 未提交读 (Read uncommitted)：事务中的修改，即使没有提交，对其它事务也是可见的。

#### 提交读
- 提交读 (Read committed)：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

#### 可重复读
- 可重复读 (Repeatable Read)：保证在同一个事务中多次读取同样数据的结果是一样的。

#### 可串行化
- 可串行化 (Serialzable)：强制事务串行执行。需要加锁实现，而其它隔离级别通常不需要。

### 多版本并发控制
- 多版本并发控制 (Multi-Version Concurrency Control, MVCC) 是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现 `提交读` 和 `可重复读` 这两种隔离级别。
- `未提交读` 隔离级别总是读取最新的数据行，无需使用 MVCC。
- `可串行化` 隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

#### 版本号
> 该版本号是指代事务的版本号。

- `系统版本号`：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- `事务版本号`：事务开始时的系统版本号。

#### 隐藏列
> 该版本号是指代数据行快照的版本号。

- MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：
	- `创建版本号`：指示创建一个数据行快照时的系统版本号；
	- `删除版本号`：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。

#### Undo 日志
- MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行 (Record) 的所有快照连接起来。

	| ![图1-9Undo日志中的快照](img/CyC2018-CS-Notes-Database_1-9.png) |
	| :---: |
	| 图 1-9 存储在 Undo日志中的快照 |

#### 实现过程
> 以下实现过程针对 `可重复读` 隔离级别。

- 当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号，理解这一点很关键。
- 数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。

##### SELECT
- 多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。
- 把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于等于 T 的版本号，因为如果大于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。
- 除此之外，T 所要读取的数据行快照的删除版本号必须是未定义或者大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。

##### INSERT
- 将当前系统版本号作为数据行快照的创建版本号。

##### DELETE
- 将当前系统版本号作为数据行快照的删除版本号。

##### UPDATE
- 将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。
- 可以理解为先执行 DELETE 后执行 INSERT。

#### 快照读与当前读
##### 快照读
- 使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。

	```sql
	SELECT * FROM table ...;
	```

##### 当前读
- 读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。

	```sql
	SELECT * FROM table WHERE ? LOCK IN SHARE MODE;
	SELECT * FROM table WHERE ? FOR UPDATE;
	INSERT;
	UPDATE;
	DELETE;
	```

### Next-Key Locks
- Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。
- MVCC 不能解决 `幻影读` 问题，Next-Key Locks 就是为了解决这个问题而存在的。
- 在可重复读 (REPEATABLE READ) 隔离级别下，使用 `MVCC + Next-Key Locks` 可以解决幻读问题。

#### Record Locks
- 锁定一个记录上的索引，而不是记录本身。
- 如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

#### Gap Locks
- 锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

	```sql
	SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
	```

#### Next-Key Locks
- 它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

	```sql
	(-∞, 10]
	(10, 11]
	(11, 13]
	(13, 20]
	(20, +∞)
	```
	
### 关系数据库设计理论
#### 函数依赖
- 记 $A \to B$ 表示 A 函数决定 B，也可以说 B 函数依赖于 A。
- 若 $\{A_1，A_2，... ，A_n\}$ 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是 `最小的`，那么该集合就称为 `键码`。
- 对于 $A \to B$，如果能找到 A 的真子集 $A'$，使得 $A' \to B$，那么 $A \to B$ 就是 `部分函数依赖`，否则就是 `完全函数依赖`。
- 对于 $A \to B$，$B \to C$，则 $A \to C$ 是一个 `传递函数依赖`。

#### 异常
- 如表 1-4 所示，展示了学生课程关系的函数依赖为 {Sno, Cname} -> {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程后就能确定其它信息。

	| Sno | Sname | Sdept | Mname | Cname | Grade |
	| :---: | :---: | :---: | :---: | :---: | :---: |
	| 1 | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90 | 
	| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80 | 
	| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100 | 
	| 3 | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95 | 

- 不符合范式的关系，会产生很多异常，主要有以下四种异常：
	- `冗余数据`：例如 `学生-2` 出现了两次。
	- `修改异常`：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
	- `删除异常`：删除一个信息，那么也会丢失其它信息。例如删除了 `课程-1` 需要删除第一行和第三行，那么 学生-1 的信息就会丢失。
	- `插入异常`：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。

#### 范式
- 范式理论是为了解决以上提到四种异常。
- 高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。

##### 第一范式 (1NF)
- 属性不可分。即数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。

##### 第二范式 (2NF)
- 每个非主属性完全函数依赖于键码。
- 可以通过分解来满足 2NF。

###### 分解前

| Sno | Sname | Sdept | Mname | Cname | Grade |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1 | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90 | 
| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80 | 
| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100 | 
| 3 | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95 | 

- 以下学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：
	- Sno -> Sname, Sdept
	- Sdept -> Mname
	- Sno, Cname-> Grade
- 函数依赖状况分析：
	- Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。  
	- Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。

###### 分解后
- 关系-1：

	| Sno | Sname | Sdept | Mname | 
	| :---: | :---: | :---: | :---: | 
	| 1 | 	学生-1 |  学院-1 | 院长-1 | 
	| 2 | 学生-2 | 学院-2 | 院长-2 | 
	| 3 | 学生-3 | 学院-2 | 院长-2 | 

- 有以下函数依赖：
	- Sno -> Sname, Sdept
	- Sdept -> Mname

- 关系-2：

	| Sno | Cname | Grade | 
	| :---: | :---: | :---: | 
	| 1 | 课程-1 | 90 | 
	| 2 | 课程-2 | 80 | 
	| 2 | 课程-1 | 100 | 
	| 3 | 课程-2 | 95 | 

- 有以下函数依赖： Sno, Cname $\to$ Grade

##### 第三范式 (3NF)
- 非主属性不传递函数依赖于键码。
- 上面的 关系-1 中存在以下传递函数依赖：Sno $\to$ Sdept $\to$ Mname。

###### 分解后
- 关系-11：

	| Sno | Sname | Sdept | 
	| :---: | :---: | :---: | 
	| 1 | 学生-1 | 学院-1 | 
	| 2 | 学生-2 | 学院-2 | 
	| 3 | 学生-3 | 学院-2 | 

- 关系-12：

	| Sdept | Mname | 
	|  :---: | :----: |
	| 学院-1 | 院长-1 | 
	| 学院-2 | 院长-2 | 

### ER 图
- 实体关系图 (Entity-Relationship，E-R)，有三个组成部分：实体、属性、联系。用来进行关系型数据库系统的概念设计。
	- `实体`：用矩形表示，矩形框内写明实体名.
	- `属性`：用椭圆形表示，并用无向边将其与相应的实体连接起来。
	- `联系`：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1...1，1...* 或 \*...\*）就是指存在的三种关系 (一对一、一对多或多对多)。
- ER 模型转换为关系模式的原则：
	- `一对一`：遇到一对一关系的话，在两个实体任选一个添加另一个实体的主键即可。
	- `一对多`：遇到一对多关系的话，在多端添加另一端的主键。
	- `多对多`：遇到多对多关系的话，我们需要将联系转换为实体，然后在该实体上加上另外两个实体的主键，作为联系实体的主键，然后再加上该联系自身带的属性即可。

	| ![图1-10简单的学生课程ER模型](img/CyC2018-CS-Notes-Database_1-10.png) |
	| :---: |
	| 图 1-10 简单的学生课程 ER 模型 |


## SQL
### 基础
- 模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。
- 主键的值不允许修改，也不允许复用；(不能将已经删除的主键值赋给新数据行的主键。
- 结构化查询语言 (Structured Query Language, SQL)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。
- SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。
- SQL 支持以下三种注释：

	```sql
	# 注释 1
	SELECT *
	FROM mytable; -- 注释 2
	
	/* 注释 3-1 */
	```

- 数据库创建与使用：
	
	```sql
	CREATE DATABASE test;
	USE test;
	```

### 创建表
- 创建表：

	```sql
	CREATE TABLE mytable (
		# int 类型，不为空，自增
		id INT NOT NULL AUTO_INCREMENT,
		# int 类型，不可为空，默认值为 1，不为空
		col1 INT NOT NULL DEFAULT 1,
		# 变长字符串类型，最长为 45 个字符，可以为空
		col2 Varchar(45) NULL,
		# 日期类型，可为空
		col3 DATE NULL,
		# 设置主键为 id
		PRIMARY KEY (`id`)
	);
	```

### 修改表
- 添加列：

	```sql
	ALTER TABLE mytable
	ADD col Char(20);
	```

- 删除列：

	```sql
	ALTER TABLE mytable
	DROP COLUMN col;
	```

- 删除表：

	```sql
	DROP TABLE mytable;
	```

### 插入

### 更新

### 删除

### 查询
#### DISTINCT
- 相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。

	```sql
	SELECT DISTINCT col1, col2
	FROM mytable;
	```

#### LIMIT
- 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。

	```sql
	# 返回前 5 行
	SELECT *
	FROM mytable
	LIMIT 5;
	
	# 返回第 3 ~ 5 行
	SELECT *
	FROM mytable
	LIMIT 2, 3;
	```
	
### 过滤
- 不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。

	```sql
	SELECT *
	FROM mytable
	WHERE col IS NULL;
	```
	
- 下表显示了 `WHERE` 子句可用的操作符：
	
	| 操作符 | 说明 | 
	| :---: | :---: | 
	| = | 等于 | 
	| < | 小于 | 
	| > | 大于 | 
	| <> != | 不等于 | 
	| <= !> | 小于等于 | 
	| >= !< | 大于等于 | 
	| BETWEEN | 在两个值之间 | 
	| IS NULL | 为 NULL 值 | 
		
	> 提示：应该注意到，NULL 与 0、空字符串都不同。
	
- `AND` 和 `OR` 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 `()` 来决定优先级，使得优先级关系更清晰。
- `IN` 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。
- `NOT` 操作符用于否定一个条件。

### 通配符
- 通配符也是用在过滤语句中，但它只能用于文本字段。
	- `%` 匹配 `>=0` 个任意字符；
	- `_` 匹配 `==1` 个任意字符；
	- `[]` 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。
- 使用 Like 来进行通配符匹配：

	```sql
	SELECT *
	FROM mytable
	WHERE col LIKE '[^AB]%'; -- 挑选不以 A 和 B 开头的任意文本
	```
	
	> 提示：不要滥用通配符，通配符位于开头处匹配会非常慢。

### 计算字段
- 在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。
- 计算字段通常需要使用 `AS` 来取别名，否则输出的时候字段名为计算表达式。

	```sql
	SELECT col1 * col2 AS alias
	FROM mytable;
	```
	
- `CONCAT()` 用于连接 (拼接) 两个字段：

	```sql
	SELECT CONCAT(col1, '(', col2, ')') AS concat_col
	FROM mytable;
	```

### 聚合函数
- 各个 DBMS 的聚合函数都是不相同的，因此不可移植。以下主要列举的是 MySQL 的聚合函数。

#### 统计汇总
| 函 数 | 说 明 | 
| :---: | :---: | 
| AVG() | 返回某列的平均值 | 
| COUNT() | 返回某列的行数 | 
| MAX() | 返回某列的最大值 | 
| MIN() | 返回某列的最小值 | 
| SUM() | 返回某列值之和 | 

```sql
# AVG() 会忽略 NULL 行
# 使用 DISTINCT 可以汇总不同的值
SELECT AVG(DISTINCT col1) AS avg_col
FROM mytable;
```

#### 文本处理
| 函 数 | 说 明 | 
| :---: | :---: | 
| LEFT() | 左边的字符
| RIGHT() | 右边的字符
| LOWER() | 转换为小写字符
| UPPER()	 | 转换为大写字符
| LTRIM() | 去除左边的空格
| RTRIM() | 去除右边的空格
| LENGTH() | 长度
| SOUNDEX() | 转换为语音值

```sql
# 其中 SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式
SELECT *
FROM mytable
WHERE SOUNDEX(col1) = SOUNDEX('apple')
```

#### 日期和时间处理

#### 数值处理

### 分组

### 排序

### 连接

### 子查询
#### 非关联子查询
 - 概念：非相关子查询是独立于外部查询的子查询，子查询执行完毕后将值传递给外部查询。子查询中只查询一次并返回一个字段的数据。
- 可以将子查询的结果作为 WHRER 语句的过滤条件：

	```sql
	SELECT *
	FROM mytable1
	WHERE col1 IN (
		SELECT col2 FROM mytable2
	);
	```
- 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：

	```sql
	SELECT cust_name, (
		SELECT COUNT(*)
		FROM Orders
		WHERE Orders.cust_id = Customers.cust_id) AS orders_num
	FROM Customers
	ORDER BY cust_name;
	```

#### 关联子查询
- 概念：关联子查询会引用外部查询中的一列或多列。这种子查询之所以被称为关联子查询，是因为子查询的确与外部查询有关。当问题的答案需要依赖于外部查询中包含的每一行中的值时，通常就需要使用关联子查询 $^{[3]}$。 
- 相关子查询的执行依赖于外部查询的数据，外部查询执行一行，子查询就执行一次。并且是外部先查询一次，然后再执行一次内部查询。
- 例如，查询部门工资前三高的所有员工 ([Leetcode](https://leetcode-cn.com/problems/department-top-three-salaries/submissions/))：

	```sql
	Select d.Name as Department, e.Name as Employee, e.Salary
	From Employee as e, Department as d
	Where 1=1 AND e.DepartmentId = d.Id
	Group By e.DepartmentId, e.id
	Having (
		Select Count(distinct es.Salary) 
		From Employee as es 
		Where 1=1 -- "1=1" 没有特殊意义，仅为了对齐语句格式
			AND e.DepartmentID = es.DepartmentID
			AND es.Salary > e.Salary
	) < 3
	```

### 组合查询


## LeetCode for SQL
- 更多题目和解题思路请参考原文 (内含在线编程连接)：[LeetCode for SQL](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database%20题解)
- 综合自己的情况，以下挑选了难度较大的题目，留作启发性笔记：
	- [181. Employees Earning More Than Their Managers](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database%20题解?id=_181-employees-earning-more-than-their-managers)
	- [184. Department Highest Salary](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database%20题解?id=_184-department-highest-salary)
	- [176. Second Highest Salary](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database%20题解?id=_176-second-highest-salary)
	- [178. Rank Scores](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database%20题解?id=_178-rank-scores)
	- [180. Consecutive Numbers](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database%20题解?id=_180-consecutive-numbers)


## MySQL


## Redis


## 参考资料
- [1] [美团技术团队. Innodb 中的事务隔离级别和锁的关系 [OL]. meituan.com, 2014](https://tech.meituan.com/2014/08/20/innodb-lock.html)
- [2] [Draveness. 浅入浅出 MySQL 和 InnoDB [OL]. draveness.me, 2017](https://draveness.me/mysql-innodb)
- [3] [普里斯 . Oracle Database 10g SQL开发指南 [M]. 清华大学出版社, 2005](https://book.douban.com/subject/1318884/)